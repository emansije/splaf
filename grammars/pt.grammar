// Adapted from <divergent>coder's toy language grammar
// http://divergentcoder.com/javascript/playing-with-peg-js/

start "início"
  = statement*

statement "declaração"
  = _ lb stmt:(attribution / if / while / print / prompt) _ lb { 
      return stmt; 
    }

attribution "atribuição"
  = id:identifiername _ "=" _ val:AdditiveExpression { 
      return { 
        type: "attribution", 
        name: id, 
        value: val 
      } 
    }

functionname "nome de função"
  = "diz"
  / "enquanto"
  / "pede"
  / "se"

reserved "reservado"
  = functionname
  / "começa"
  / "e"
  / "então"
  / "não"
  / "ou"
  / "termina"

identifiername "identificador"
  = !reserved
    first:[a-zA-Z_áàãâéêíóõôúçÁÀÃÂÉÊÍÓÕÔÚÇ]
    rest:[0-9a-zA-Z_áàãâéêíóõôúçÁÀÃÂÉÊÍÓÕÔÚÇ]* {
      return first + rest.join("")
    }

MultiplicativeExpression
  = head:literal
    tail:(_ MultiplicativeOperator _ literal)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type:     "binaryop",
          operator: tail[i][1],
          args:     [result, tail[i][3]]
        };
      }
      return result;
    }

MultiplicativeOperator
  = operator:("*" / "/" / "%") !"=" { return operator; }

AdditiveExpression
  = head:MultiplicativeExpression
    tail:(_ AdditiveOperator _ MultiplicativeExpression)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type:     "binaryop",
          operator: tail[i][1],
          args:     [result, tail[i][3]]
        };
      }
      return result;
    }

AdditiveOperator
  = [+-]

UnitaryExpression "expressão unitária"
  = op:("não" / "-") _ operand:(UnitaryExpression / AdditiveExpression) {
      return { 
        type: "unaryop", 
        operator: op, 
        arg: operand 
      }
    }
  / primary

oper "operador"
  = ">="
  / "<="
  / "=="
  / "igual a"
  / "é igual a"
  / "for igual a"
  / "!="
  / "diferente de"
  / "é diferente de"
  / "for diferente de"
  / [+-/\*^%<>]

primary "expressão primária"
  = (identifier / literal / parentesis)

identifier "identificador"
  = id:identifiername { 
      return {
        type: "variable", 
        name:id
      }
    }

literal "literal"
  = val:(real / integer / text) {
      return {
        type: "literal",
        value: val
      }
    }

integer "inteiro"
  = digits:[0-9]+ { 
      return parseInt(digits.join("")); 
    }

real "real"
  = digits:(integer "." integer) { 
      return parseFloat(digits.join("")); 
    }

text "texto"
  = '"' str:([^\"]*) '"' {
      return str.join("")
    }

parentesis "parêntesis"
  = "(" val:AdditiveExpression ")" {
      return val
    }

block "bloco"
  = _ "começa" _ lb stmts:statement* _ lb "termina" {
      return {
        type: "block",
        code: stmts
      }
    }

if "se"
  = "se" ws+ cond:AdditiveExpression ws+ "então" _ lb
    _ ifval:(statement / block) _ lb
    _ elseval:("senão" _ lb (statement / block))? _ lb {
      return {
        type: "if",
        condition: cond,
        value: ifval,
        elsevalue: elseval ? elseval[3] : null
      }
    }

while "enquanto"
  = "enquanto" ws+ cond:AdditiveExpression _ lb
    _ whileval:(statement / block) _ lb {
      return {
        type: "while",
        condition: cond,
        value: whileval
      }
    }

prompt "pedido"
  = "pede" ws+ id:identifiername _ lb {
      return {
        type: "prompt",
        name: id
      }
    }

print "apresentação"
  = "diz" ws+ args:((ws? AdditiveExpression)+)? _ lb {
      return {
        type: "print",
        arguments: args ? args.map(function(a) { return a[1] }) : null
      }
    }

ws "um espaço em branco"
  = [ \t]

lb "mudança de linha"
  = [\r\n]*

_ "espaço em branco"
  = ws*
